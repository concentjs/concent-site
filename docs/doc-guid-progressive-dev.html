<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>渐进式的开发 · concent</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="&lt;hr&gt;
"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="渐进式的开发 · concent"/><meta property="og:type" content="website"/><meta property="og:url" content="https://concentjs.github.io/concent-site/concent-site/"/><meta property="og:description" content="&lt;hr&gt;
"/><meta property="og:image" content="https://concentjs.github.io/concent-site/concent-site/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://concentjs.github.io/concent-site/concent-site/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/concent-site/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://concentjs.github.io/concent-site/concent-site/blog/atom.xml" title="concent Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://concentjs.github.io/concent-site/concent-site/blog/feed.xml" title="concent Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/concent-site/css/main.css"/><script src="/concent-site/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/concent-site/"><img class="logo" src="/concent-site/img/favicon.ico" alt="concent"/><h2 class="headerTitleWithLogo">concent</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/concent-site/docs/doc-intro-what-is-concent" target="_self">Docs</a></li><li class=""><a href="/concent-site/docs/api-top-run" target="_self">API</a></li><li class=""><a href="/concent-site/docs/release-v1-1-26" target="_self">发布日志</a></li><li class=""><a href="/concent-site/help" target="_self">Help</a></li><li class=""><a href="/concent-site/blog/" target="_self">Blog</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>新手指南</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">序言</h3><ul class=""><li class="navListItem"><a class="navItem" href="/concent-site/docs/doc-intro-what-is-concent">concent是什么</a></li><li class="navListItem"><a class="navItem" href="/concent-site/docs/doc-intro-compare-others">对比redux和mobx</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">新手指南</h3><ul class=""><li class="navListItem"><a class="navItem" href="/concent-site/docs/doc-guid-quick-start">快速开始</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/concent-site/docs/doc-guid-progressive-dev">渐进式的开发</a></li><li class="navListItem"><a class="navItem" href="/concent-site/docs/doc-guid-standard-dev">标准化的开发</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">核心概念与功能</h3><ul class=""><li class="navListItem"><a class="navItem" href="/concent-site/docs/doc-core-module">模块</a></li><li class="navListItem"><a class="navItem" href="/concent-site/docs/doc-core-component">组件</a></li><li class="navListItem"><a class="navItem" href="/concent-site/docs/doc-core-reducer">reducer</a></li><li class="navListItem"><a class="navItem" href="/concent-site/docs/doc-core-debug">调试</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">生态与周边</h3><ul class=""><li class="navListItem"><a class="navItem" href="/concent-site/docs/doc-eco-router">react-router-concent</a></li><li class="navListItem"><a class="navItem" href="/concent-site/docs/doc-eco-loading">concent-loading</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">精彩示例</h3><ul class=""><li class="navListItem"><a class="navItem" href="/concent-site/docs/doc-case-antd-pro">concent-antd-pro</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">渐进式的开发</h1></header><article><div><span><hr>
<p>得益于<code>concent</code>弹性的api设计，和非入侵式的接入方式，用户可以基于经典的<code>react</code>编码方式逐步改造或者重构，你也可以根据实际情况局部使用，在根据后续发展情况决定是否要接入到整个应用，这种平滑的过度方式给予用户更多的灵活&amp;自由度。</p>
<h2><a class="anchor" aria-hidden="true" id="需求"></a><a href="#需求" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>需求</h2>
<p>我么先给自己假设一个功能需求：需要提供这样一个页面给用户，界面上绘制一个input框，支持用户输入任意字符，用户输入内容并提交后，如果是首次输入<code>666</code>就给用户发放奖励，并给用户添加积分，积分大于1000的时候展示为1000+、2000+，以此类推，同时当用户关闭奖励面板时，上报一次关闭行为发生的数据。</p>
<h2><a class="anchor" aria-hidden="true" id="传统写法"></a><a href="#传统写法" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>传统写法</h2>
<p>我们按照传统写法来实现一遍 <a href="https://stackblitz.com/edit/cc-course-award-panel-v1?file=index.js">在线示例</a>:</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AwardPanel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-keyword">constructor</span>(props, context) {
    <span class="hljs-keyword">super</span>(props, context);
    <span class="hljs-keyword">this</span>.state = {
      <span class="hljs-attr">mask</span>: <span class="hljs-literal">false</span>,<span class="hljs-comment">//用于用户中奖时，禁止用户的后续操作</span>
      inputCode: <span class="hljs-string">''</span>,<span class="hljs-comment">//用户输入的内容</span>
      awardList: [],<span class="hljs-comment">//已获得的奖励列表</span>
      bonus: <span class="hljs-number">0</span>,<span class="hljs-comment">//已获得的积分</span>
      displayBonus: <span class="hljs-number">0</span>,<span class="hljs-comment">//用于展示的积分</span>
    }
  }
  <span class="hljs-comment">/** 首次挂载完毕，做初始化动作 */</span>
  componentDidMount() {
    <span class="hljs-keyword">this</span>.init();
  }
  <span class="hljs-comment">/** 关闭时上报关闭行为 */</span>
  componentWillUnmount(){
    api.track(<span class="hljs-string">'closeAwardPanel'</span>);
  }
  <span class="hljs-comment">/** 初始化获取奖励和积分 */</span>
  init = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">this</span>.setState({<span class="hljs-attr">mask</span>:<span class="hljs-literal">true</span>});
    <span class="hljs-built_in">Promise</span>.all([
      api.fetchAwardList().then(<span class="hljs-function"><span class="hljs-params">awardList</span> =&gt;</span> <span class="hljs-keyword">this</span>.setState({ awardList })),
      api.fetchBonus().then(<span class="hljs-keyword">this</span>.convertBonus)
    ]).then(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span><span class="hljs-keyword">this</span>.setState({<span class="hljs-attr">mask</span>:<span class="hljs-literal">false</span>}));
  }
  <span class="hljs-comment">/** 转换积分 */</span>
  convertBonus = <span class="hljs-function">(<span class="hljs-params">bonus</span>) =&gt;</span> {
    <span class="hljs-keyword">let</span> displayBonus;
    <span class="hljs-keyword">if</span> (bonus &lt; <span class="hljs-number">1000</span>) {
      displayBonus = bonus;
    } <span class="hljs-keyword">else</span> {
      displayBonus = <span class="hljs-built_in">parseInt</span>(bonus / <span class="hljs-number">1000</span>) * <span class="hljs-number">1000</span> + <span class="hljs-string">'+'</span>;
    }
    <span class="hljs-keyword">this</span>.setState({ bonus, displayBonus });
  }
  <span class="hljs-comment">/** 处理输入变化 */</span>
  handleStrChange = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> { awardList } = <span class="hljs-keyword">this</span>.state;
    <span class="hljs-keyword">const</span> inputCode = e.currentTarget.value;
    <span class="hljs-keyword">const</span> toSet = { inputCode };
    <span class="hljs-comment">//首次中奖</span>
    <span class="hljs-keyword">if</span> (inputCode === <span class="hljs-string">'666'</span> &amp;&amp; !awardList.find(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v.code === <span class="hljs-string">'666'</span>)) {
      api.giveUserAward(userId, inputCode).then(<span class="hljs-keyword">this</span>.init);
    }
    <span class="hljs-keyword">this</span>.setState(toSet);
  }
  render() {
    <span class="hljs-keyword">const</span> { mask, inputCode, awardList, displayBonus } = <span class="hljs-keyword">this</span>.state;
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{stBox}</span>&gt;</span>
        {
          mask ? <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{stMask}</span>&gt;</span>loading<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> : ''
        }
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{inputCode}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{this.handleStrChange}</span> /&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.init}</span>&gt;</span>刷新<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>awardList: {awardList.map((v, idx) =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{v.name} *{v.num}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>)}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>displayBonus: {displayBonus}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    );
  }
}
</span></code></pre>
<blockquote>
<p>可以看出，整个AwardPanel类里已经包含不少业务逻辑，当某一天我们需要在另一处也写一个奖励面板时，除了ui，业务都是要复用的，这种混杂在一起的写法，随着迭代的深入，终将会面临着到处都充斥着重复的代码。</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="抽象模块"></a><a href="#抽象模块" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>抽象模块</h2>
<p>我们这里抽象出一个业务模块<code>award</code>，把<code>AwardPanel</code>看做消费<code>award</code>模块状态的组件之一，将来可能有其他组件需要消费<code>award</code>模块的状态时，就可以很方便的连接到<code>award</code>模块了。</p>
<p>上例中显然<code>awardList</code>、<code>bonus</code>和<code>displayBonus</code>是属于<code>award</code>业务模块，剩下的<code>mask</code>和<code>inputCode</code>属于组件实例自己独立维护的和业务无关的状态，我们将<code>awardList</code>、<code>bonus</code>和<code>displayBonus</code>抽离出来，交给<a href="api-top-run">run</a>启动时载入</p>
<pre><code class="hljs"><span class="hljs-keyword">import</span> { <span class="hljs-built_in">run</span>, <span class="hljs-keyword">register</span> } from <span class="hljs-string">'concent'</span>;
<span class="hljs-built_in">run</span>({
  award:{
    state:{
      awardList: [],<span class="hljs-comment">//已获得的奖励列表</span>
      bonus: <span class="hljs-number">0</span>,<span class="hljs-comment">//已获得的积分</span>
      displayBonus: <span class="hljs-number">0</span>,<span class="hljs-comment">//用于展示的积分</span>
    }
  }
});

</code></pre>
<h2><a class="anchor" aria-hidden="true" id="注册成为concent类-指定所属模块"></a><a href="#注册成为concent类-指定所属模块" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>注册成为concent类，指定所属模块</h2>
<p>载入<code>award</code>模块后，所有concent组件可以消费指定模块的数据了，我们将上面基于写好的<code>AwardPanel</code>，一行代码都不用改动得情况下，使用<a href="api-top-register">register</a>函数直接注册为concent组件<code>AwardPanel_</code>后，再交给react渲染</p>
<pre><code class="hljs">const AwardPanel_ = register(
  'AwardPanel', 
  {
    module:'award', //指定该组件属于award模块
    //共享award模块的所有状态变化，等同于写为 ['awardList','bonus','displayBonus']
    sharedStateKeys:'*',
  }
)(<span class="hljs-name">AwardPanel</span>)<span class="hljs-comment">;</span>
</code></pre>
<blockquote>
<p>运行起来后，<code>concent</code>将整个<code>store</code>绑定在<code>window.sss</code>下(后期会提供dev-tool，方便用户可视化的查看store)，用户可以在<code>console</code>输入<code>sss</code>并回车，就可以查看<code>concent</code>的整个<code>store</code>数据了</p>
</blockquote>
<p><img src="/concent-site/img/cc-sss-show.png" alt="查看store"></p>
<h2><a class="anchor" aria-hidden="true" id="改造完成"></a><a href="#改造完成" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>改造完成</h2>
<p>至此我们再上下文做了3件事情，<b>源代码一行没有改动</b>，该示例依然能够完美正常运行。</p>
<ul>
<li>申明一个模块</li>
<li>载入模块，启动concent</li>
<li>将组件注册为cc组件，提升state到store</li>
</ul>
<p><a href="https://stackblitz.com/edit/cc-course-award-panel-v2">在线示例</a></p>
<h2><a class="anchor" aria-hidden="true" id="抽象reducer函数"></a><a href="#抽象reducer函数" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>抽象reducer函数</h2>
<p>reducer函数是我们负责处理数据的核心逻辑，我们在以上基础上继续改造，将上述例子中的<code>init</code>、<code>handleStrChange</code>，放在一个<code>reducer.js</code>文件里，以便达到业务逻辑和渲染逻辑分离的效果</p>
<pre><code class="hljs"><span class="hljs-comment">// model/reducer.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">track</span>(<span class="hljs-params">ev</span>)</span>{
  alert(ev);
  api.track(ev);
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setMask</span>(<span class="hljs-params">mask</span>)</span>{
  <span class="hljs-keyword">return</span> {mask};
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchAwardList</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">const</span> awardList = <span class="hljs-keyword">await</span> api.fetchAwardList();
  <span class="hljs-keyword">return</span> {awardList};
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchBonus</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">const</span> bonus = <span class="hljs-keyword">await</span> api.fetchBonus();
  <span class="hljs-keyword">return</span> {bonus};
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span>(<span class="hljs-params">payload, moduleState, ctx</span>)</span>{
  <span class="hljs-comment">//开启遮罩效果，注意虽然setMask本身不是一个async函数，</span>
  <span class="hljs-comment">//但是concent将所有reducer函数保证为promise函数，所以这里可以使用await</span>
  <span class="hljs-comment">//await ctx.dispatch(setMask, true);</span>

  <span class="hljs-comment">//但是因其setMask内部并没有异步逻辑，所以这里忽略await</span>
  <span class="hljs-comment">//逻辑依然是从上往下按顺序串行执行的</span>
  ctx.dispatch(  setMask, <span class="hljs-literal">true</span>);

  <span class="hljs-comment">//获取奖励列表</span>
  <span class="hljs-keyword">await</span> ctx.dispatch(fetchAwardList);
  <span class="hljs-comment">//可以基于字符串调用reducer，因为当前同一个模块的reducer函数处于同一个文件，可以直接写函数</span>
  <span class="hljs-comment">//await ctx.dispatch('fetchAwardList');</span>

  <span class="hljs-comment">//获取积分</span>
  <span class="hljs-keyword">await</span> ctx.dispatch(fetchBonus);
  <span class="hljs-comment">//关闭遮罩效果</span>
  ctx.dispatch(setMask, <span class="hljs-literal">false</span>);
}

<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setState</span>(<span class="hljs-params">state</span>)</span>{
  <span class="hljs-keyword">return</span> state;
}

<span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleInputCodeChange</span>(<span class="hljs-params">inputCode, moduleState, ctx</span>)</span>{
  <span class="hljs-keyword">const</span> { awardList, mask } = moduleState;
  <span class="hljs-keyword">if</span>(mask) <span class="hljs-keyword">return</span>;<span class="hljs-comment">//请求中，不接受新的输入</span>
  <span class="hljs-comment">//首次中奖</span>
  <span class="hljs-keyword">if</span> (inputCode === <span class="hljs-string">'666'</span> &amp;&amp; !awardList.find(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v.code === <span class="hljs-string">'666'</span>)) {
    ctx.dispatch(setState, {inputCode, <span class="hljs-attr">mask</span>:<span class="hljs-literal">true</span>});
    <span class="hljs-keyword">await</span> api.giveUserAward(userId, inputCode);
    <span class="hljs-keyword">await</span> ctx.dispatch(init);
  }<span class="hljs-keyword">else</span>{
    ctx.dispatch(setState, {inputCode});
  }
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="抽离computed函数"></a><a href="#抽离computed函数" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>抽离computed函数</h2>
<p>我们注意到bonus是一个需要进一步计算的值，我们当然可以直接在reducer里直接处理，然后放在state里，但是更好的做法是，对bonus写一个computed函数，这样的话，计算结果会被缓存，只有当bonus发生变化时，才会重新计算</p>
<pre><code class="hljs"><span class="hljs-comment">//model/computed.js</span>

export <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bonus</span></span>(<span class="hljs-keyword">new</span><span class="hljs-type">Val</span>, oldVal){
  let displayBonus;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Val</span> &lt; <span class="hljs-number">1000</span>) {
    displayBonus = <span class="hljs-keyword">new</span><span class="hljs-type">Val</span>;
  } <span class="hljs-keyword">else</span> {
    displayBonus = parseInt(<span class="hljs-keyword">new</span><span class="hljs-type">Val</span> / <span class="hljs-number">1000</span>) * <span class="hljs-number">1000</span> + <span class="hljs-string">'+'</span>;
  }
  <span class="hljs-keyword">return</span> displayBonus;
}

</code></pre>
<blockquote>
<p>计算后的结果将搜集在<code>$$moduleComputed</code>里，render期间可以通过<code>this.$$moduleComputed.{key}</code>获得结果</p>
</blockquote>
<h2><a class="anchor" aria-hidden="true" id="concent组件改造完成"></a><a href="#concent组件改造完成" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>concent组件改造完成</h2>
<p>然后我们将原来的类改写为如下示例</p>
<pre><code class="hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AwardPanel</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  <span class="hljs-comment">/** 首次挂载完毕，做初始化动作 */</span>
  componentDidMount() {
    <span class="hljs-keyword">this</span>.$$dispatch(<span class="hljs-string">'init'</span>);
  }
  <span class="hljs-comment">/** 关闭时上报关闭行为 */</span>
  componentWillUnmount(){
    <span class="hljs-keyword">this</span>.$$dispatch(<span class="hljs-string">'track'</span>);
  }
  <span class="hljs-comment">/** 处理输入变化 */</span>
  handleStrChange = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> inputCode = e.currentTarget.value;
    <span class="hljs-keyword">this</span>.$$dispatch(<span class="hljs-string">'handleInputCodeChange'</span>, inputCode);
  }
  render() {
    <span class="hljs-keyword">const</span> { mask, inputCode, awardList, displayBonus } = <span class="hljs-keyword">this</span>.state;
    <span class="hljs-keyword">const</span> { <span class="hljs-attr">bonus</span>:displayBonus } = <span class="hljs-keyword">this</span>.$$moduleComputed;
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{stBox}</span>&gt;</span>
        {
          mask ? <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{stMask}</span>&gt;</span>loading<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> : ''
        }
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{inputCode}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{this.handleStrChange}</span> /&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{this.init}</span>&gt;</span>刷新<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>awardList: {awardList.map((v, idx) =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{v.name} *{v.num}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>)}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>displayBonus: {displayBonus}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    );
  }
}
</span></code></pre>
<p>我们抽离完reducer函数和computed函数，可以发现ui逻辑已经轻薄很多，这将有利于后续的维护与迭代.</p>
<p><a href="https://stackblitz.com/edit/cc-course-award-panel-v3">在线示例</a></p>
<h2><a class="anchor" aria-hidden="true" id="升级为函数式组件"></a><a href="#升级为函数式组件" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>升级为函数式组件</h2>
<p>class写法会让用户面临着不少<code>this.</code>的调用，<code>concent</code>基于<code>CcFragment</code>抽象了<code>connectDumb</code>函数，让用户可以淋漓痛快的用函数式的语法书写你的ui逻辑</p>
<h3><a class="anchor" aria-hidden="true" id="定义setup"></a><a href="#定义setup" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>定义setup</h3>
<p>setup在组件初次渲染前执行一次，返回的结果将返回到<code>ctx.settings</code>里</p>
<pre><code class="hljs"><span class="hljs-keyword">const</span> setup = <span class="hljs-function"><span class="hljs-params">ctx</span> =&gt;</span> {
  <span class="hljs-comment">//定义副作用，第二位参数写空数组，表示只在组件初次挂载完毕后执行一次</span>
  ctx.defineEffect(<span class="hljs-function"><span class="hljs-params">ctx</span> =&gt;</span> {
    ctx.dispatch(<span class="hljs-string">'init'</span>);
    <span class="hljs-comment">//返回清理函数，组件卸载时将触发此函数</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ctx.dispatch(<span class="hljs-string">'track'</span>, <span class="hljs-string">'user close award panel'</span>)
  }, []);

  <span class="hljs-comment">//定义handleStrChange方法</span>
  <span class="hljs-keyword">const</span> handleStrChange = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> inputCode = e.currentTarget.value;

    <span class="hljs-comment">//两种写法等效</span>
    ctx.dispatch(<span class="hljs-string">'handleInputCodeChange'</span>, inputCode);
    <span class="hljs-comment">// ctx.reducer.award.handleInputCodeChange(inputCode);</span>
  }

  <span class="hljs-comment">//定义init函数</span>
  <span class="hljs-keyword">const</span> init = ctx.reducer.award.init;
  <span class="hljs-comment">//const init = ()=&gt; ctx.dispatch('init');</span>

  <span class="hljs-comment">//setup会将返回结果放置到settings</span>
  <span class="hljs-keyword">return</span> { handleStrChange, init };
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="定义mapprops"></a><a href="#定义mapprops" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>定义mapProps</h3>
<p>函数组件每次渲染前，mapProps都会被调用，帮助用户组装想要的props数据</p>
<pre><code class="hljs"><span class="hljs-keyword">const</span> mapProps = ctx =&gt; {
  <span class="hljs-comment">//将bonus的计算结果取出</span>
  <span class="hljs-keyword">const</span> displayBonus = ctx.connectedComputed.award.bonus;
  <span class="hljs-comment">//将settings里的 handleStrChange方法、init方法 取出</span>
  <span class="hljs-keyword">const</span> { handleStrChange, <span class="hljs-keyword">init</span> } = ctx.settings;
  <span class="hljs-comment">//将inputCode取出</span>
  <span class="hljs-keyword">const</span> { inputCode, awardList, mask } = ctx.connectedState.award;

  <span class="hljs-comment">//该返回结果会映射到组件的props上</span>
  <span class="hljs-keyword">return</span> { <span class="hljs-keyword">init</span>, mask, inputCode, awardList, displayBonus, handleStrChange }
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="定义函数组件"></a><a href="#定义函数组件" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>定义函数组件</h3>
<p>用户可以书写function组件，只负责描述UI，绑定数据和方法</p>
<pre><code class="hljs"><span class="hljs-keyword">const</span> AwardPanelUI = <span class="hljs-function">(<span class="hljs-params">props</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{stBox}</span>&gt;</span>
      {
        props.mask ? <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{stMask}</span>&gt;</span>loading<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> : ''
      }
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">{props.inputCode}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{props.handleStrChange}</span> /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{props.init}</span>&gt;</span>刷新<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>awardList: {props.awardList.map((v, idx) =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">key</span>=<span class="hljs-string">{idx}</span>&gt;</span>{v.name} *{v.num}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>)}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>displayBonus: {props.displayBonus}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  );
};
</span></code></pre>
<h3><a class="anchor" aria-hidden="true" id="连接到模块"></a><a href="#连接到模块" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>连接到模块</h3>
<p>我们使用<code>connectDumb</code>将函数组件连接到模块，生成一个新的函数组件</p>
<pre><code class="hljs"><span class="hljs-keyword">const</span> AwardPanel = connectDumb({
  <span class="hljs-built_in">setup</span>, <span class="hljs-comment">//传入预先定义好的setup</span>
  mapProps, <span class="hljs-comment">//传入预先定义好的mapProps</span>
  <span class="hljs-built_in">connect</span>:{award:<span class="hljs-string">'*'</span>}, <span class="hljs-comment">//将AwardPanelUI连接到award模块，观察该模块的所有key变化</span>
})(AwardPanelUI);
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="升级完毕"></a><a href="#升级完毕" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>升级完毕</h3>
<p>经过以上几步操作，我们已经将<code>AwardPanel</code>由class写法改为function写法，具体该用哪一种写法取决于用户的个人喜好，但是function组件可以灵活组合，更加面向函数式书写体验。</p>
<p><a href="https://stackblitz.com/edit/cc-course-award-panel-v4?file=index.js">在线示例</a></p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/concent-site/docs/doc-guid-quick-start"><span class="arrow-prev">← </span><span>快速开始</span></a><a class="docs-next button" href="/concent-site/docs/doc-guid-standard-dev"><span>标准化的开发</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#需求">需求</a></li><li><a href="#传统写法">传统写法</a></li><li><a href="#抽象模块">抽象模块</a></li><li><a href="#注册成为concent类-指定所属模块">注册成为concent类，指定所属模块</a></li><li><a href="#改造完成">改造完成</a></li><li><a href="#抽象reducer函数">抽象reducer函数</a></li><li><a href="#抽离computed函数">抽离computed函数</a></li><li><a href="#concent组件改造完成">concent组件改造完成</a></li><li><a href="#升级为函数式组件">升级为函数式组件</a><ul class="toc-headings"><li><a href="#定义setup">定义setup</a></li><li><a href="#定义mapprops">定义mapProps</a></li><li><a href="#定义函数组件">定义函数组件</a></li><li><a href="#连接到模块">连接到模块</a></li><li><a href="#升级完毕">升级完毕</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/concent-site/" class="nav-home"><img src="/concent-site/img/favicon.ico" alt="concent" width="66" height="58"/></a><div><h5>Docs</h5><a href="/concent-site/docs/en/doc1.html">Getting Started (or other categories)</a><a href="/concent-site/docs/en/doc2.html">Guides (or other categories)</a><a href="/concent-site/docs/en/doc3.html">API Reference (or other categories)</a></div><div><h5>Community</h5><a href="/concent-site/en/users.html">User Showcase</a><a href="http://stackoverflow.com/questions/tagged/" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://discordapp.com/">Project Chat</a><a href="https://twitter.com/" target="_blank" rel="noreferrer noopener">Twitter</a></div><div><h5>More</h5><a href="/concent-site/blog">Blog</a><a href="https://github.com/">GitHub</a><a class="github-button" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><a href="https://opensource.facebook.com/" target="_blank" rel="noreferrer noopener" class="fbOpenSource"><img src="/concent-site/img/oss_logo.png" alt="Facebook Open Source" width="170" height="45"/></a><section class="copyright">Copyright © 2019 Your Name or Your Company Name</section></footer></div></body></html>